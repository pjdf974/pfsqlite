var child = require("child_process");

var ClassSqlite = (function(){

	function ClassSqlite(databasename, exename){
		if(databasename == ":memory:") throw new Error("Ne gere pas les databases ':memory:'");
		databasename = databasename || process.cwd()+"/defaultdatabasename.bdd";
		exename = exename || "node_modules/pfsqlite/sqlite_exe/sqlite3.exe";
		this.exename = exename.replace(/\\/g, "/")
		this.databasename = databasename.replace(/\\/g, "/");
	};

	ClassSqlite.prototype.newBufferBinary = function(chaine){
		// remplace new Buffer(chaine, 'binary') qui sera obsolète dans les futures versions de node.js
		var array = [];
		for (var i = 0, l=chaine.length; i < l; ++i) {
                array.push(chaine.charCodeAt(i));
            };
        return(new Buffer(array));
	};

	ClassSqlite.prototype.toStringBinary = function(buffer){
		// remplace toString(buffer, 'binary') qui sera obsolète dans les futures versions de node.js
        return(String.fromCharCode.apply(String, buffer));
    };

	ClassSqlite.prototype.execute = function(request, callback){
		var error = null;
		if(!request) error = "Aucune requete sql";
		if(request.substring(0,1)==".") error = "Ne gere pas les commandes en ligne de 'sqlite3.exe'";
		if(error){
			callback(error, null);
		} else {
			var that            = this;
			var sauveEnregis    = "";
			var enregistrements = [];
	        var requestBuffer   = new Buffer(request, "utf8");
			//var sql = child.exec('"'+that.exename+'" "'+databasepath+'" "'+requestBuffer.toString("utf8")+'"');
			var sql = child.spawn(that.exename, [that.databasename, requestBuffer]);
			var n=0;
			sql.stdout.on(
				"data",
				function(contentBuffer){
					// on ajoute sauveEnregis au début en cas de tronquage
					// voir l'explication en fin du script
					enregistrements = (sauveEnregis+that.toStringBinary(contentBuffer)).split("\r\n");
					for(var i in enregistrements){
						if(i==enregistrements.length-1){ //dernier item qui peut-être tronqué  
							sauveEnregis = enregistrements[i];
						} else {
							n++;
							//console.log(n);
							callback(false, enregistrements[i].split("|"));
						};
					};
				}
			);
			sql.stderr.on(
				"data",    // c'est 'data' et non 'error'
				function(error){
					callback(error.toString(), null);
					//console.log("ERREUR A : ----------------------------------------");
				}
			);
			sql.on(
				"close",
				function(){
					callback(false, "EOF");
				}
			);
		};
	};

	ClassSqlite.prototype.executescript = function(script, callback){
		var that     = this;
		script = script.replace(/;$/, "");  // effacer le dernier ';'' en fin de 'script' s'il' existe
		var requests = script.split(";");
		var index    = -1;
		var taille = requests.length-1;
		executeRequest();
		function executeRequest(error, no_use){
			if(error){
				callback(error, no_use);
			} else {
				index++;
				if(index<taille){
					that.execute(requests[index], executeRequest);
				} else {
					if(requests[index]){
						that.execute(requests[index], callback);
					};
				};
			};
		};
	};
	return(ClassSqlite);
})();

var module = module || undefined;  // évite un warning si on utilise node-webkit
if(module != undefined){
	module.exports = ClassSqlite;
};
